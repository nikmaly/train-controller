#ifndef ROTARYENCODER_H
#define ROTARYENCODER_H

/**
 * @typedef {Object} EncoderCommand
 * @property {String} target - The target of the command (e.g., "motor").
 * @property {String} action - The action to be performed (e.g., "speed", "switch").
 * @property {String} value - The value associated with the action (e.g., speed value).
 * @property {bool} trackSwapRequested - Indicates if a track swap has been requested.
 */
struct EncoderCommand {
  String target;
  String action;
  String value;
  bool trackSwapRequested;

  bool isValid() {
    return target.length() > 0 && action.length() > 0;
  }
};

class RotaryEncoder {
 private:
  int pinCLK;
  int pinDT;
  int pinSwitch;
  volatile int count = 0;
  boolean bool_CW;
  MotorDriver* activeTrackLine;
  MotorDriver* trackLineA;
  MotorDriver* trackLineB;

  static RotaryEncoder* instance;

  static void handleInterruptCLK() {
    if (instance) {
      instance->updateCount();
    }
  }

  void updateCount() {
    if (digitalRead(pinDT) != digitalRead(pinCLK)) {
      count++;
      bool_CW = true;
    } else {
      count--;
      bool_CW = false;
    }
    count = constrain(count, -10, 10);
  }

 public:
  /**
   * Constructs a RotaryEncoder object.
   * @param {int} pinCLK - The pin connected to the CLK signal of the rotary encoder.
   * @param {int} pinDT - The pin connected to the DT signal of the rotary encoder.
   * @param {int} pinSwitch - The pin connected to the switch of the rotary encoder.
   * @param {MotorDriver*} trackLineA - Pointer to the first track line motor driver.
   * @param {MotorDriver*} trackLineB - Pointer to the second track line motor driver.
   */
  RotaryEncoder(
    int pinCLK,
    int pinDT,
    int pinSwitch,
    MotorDriver* trackLineA,
    MotorDriver* trackLineB
  ) : pinCLK(pinCLK),
      pinDT(pinDT),
      pinSwitch(pinSwitch),
      activeTrackLine(trackLineA),
      trackLineA(trackLineA),
      trackLineB(trackLineB) {
        pinMode(pinCLK, INPUT);
        pinMode(pinDT, INPUT);
        pinMode(pinSwitch, INPUT_PULLUP);
        instance = this;
        attachInterrupt(digitalPinToInterrupt(pinCLK), handleInterruptCLK, CHANGE);
      }

  /**
   * Updates the state of the rotary encoder and returns an instruction set.
   * @returns {EncoderCommand} The command generated by the rotary encoder.
   */
  EncoderCommand update() {
    EncoderCommand command = {"", "", "", false};

    // Map the encoder value to motor speed at a 10:1 ratio
    int speedValue = count * 10;
    command.target = "motor";
    command.action = "speed";
    command.value = String(speedValue);

    // Check if button is pressed (pinSwitch)
    if (digitalRead(pinSwitch) == LOW) {
      command.trackSwapRequested = true;
      command.target = "motor";
      command.action = "switch";

      delay(500);  // Debounce delay
    }

    return command;
  }
};

RotaryEncoder* RotaryEncoder::instance = nullptr;

#endif  // ROTARYENCODER_H